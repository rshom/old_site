<!DOCTYPE html>
<html>
  <head>
    <meta name="viewport" content="width=device-width">
    <title>Get geolocation every second</title>
    <link rel="stylesheet" type="text/css" href="style.css" />
    <script>


// Radius of earth in meters'
//var R = 6371e3;
var R = 6371000;// I don't trust math unnecessarily
var currentLat = 0; // I'll update these inside the postion function
var currentLon = 0;
// target must be a global variable, so I can see it
var target;

    
var getCurrentPositionRequest = 0;

//// deg_to_rad
function deg_to_rad(degs) {
    return degs*Math.PI/180;
}

function rad_to_deg(rads) {
    // blah
    var degs = rads*180/Math.PI;
    return degs;
}

function find_endpoint(lat,lon,distance,bearing) {
    // Make sure this is correct
    var lat1 = deg_to_rad(lat);
    var lon1 = deg_to_rad(lon);
    var lat2;
    var lon2;
    var brng = deg_to_rad(bearing);
    var d = distance;
    var lat2 = Math.asin( Math.sin(lat1)*Math.cos(d/R) + 
			  Math.cos(lat1)*Math.sin(d/R)*Math.cos(brng) );
    var lon2 = lon1 + Math.atan2(Math.sin(brng)*Math.sin(d/R)*Math.cos(lat1),
				 Math.cos(d/R)-Math.sin(lat1)*Math.sin(lat2));
    return {
	lat: rad_to_deg(lat2),
	lon: rad_to_deg(lon2)
    };
}

function find_distance(lat1,lon1,lat2,lon2) {
    // find between two points in meters
    // performance matters and small distances
    //// test these assumptions
    //// therefore pythagoran's theorem on an equilatoral projection is fine
    lat1 = deg_to_rad(lat1)
    lat2 = deg_to_rad(lat2)
    lon1 = deg_to_rad(lon1)
    lon2 = deg_to_rad(lon2)
    var x = (lon2-lon1)*Math.cos((lat1+lat2)/2);
    var y = lat2-lat1;
    var distance = Math.sqrt(x*x+y*y)*R; //meters
    return distance;
}
function find_bearing(lat1,lon1,lat2,lon2) {
    // find bearing from one point to another in degrees
    // take a closer look at this function. It works now, but something is wrong with it.
    lat1 = deg_to_rad(lat1)
    lat2 = deg_to_rad(lat2)
    lon1 = deg_to_rad(lon1)
    lon2 = deg_to_rad(lon2)
    var x = (lon2-lon1)*Math.cos((lat1+lat2)/2);
    var y = lat2-lat1;
    var bearing = Math.atan2(x,y); 
    return rad_to_deg(bearing); // degrees
}

function getTime() {
    var now = new Date();
    var time = '' + now.getUTCHours() + ':';
    if (now.getUTCMinutes() < 10) time += '0';
    time += now.getUTCMinutes() + ':';
    if (now.getUTCSeconds() < 10) time += '0';
    time += now.getUTCSeconds();
    //time += ':' + now.getUTCMilliseconds();
    return time;
}

function formatTime(date) {
    var time = '' + date.getUTCHours() + ':';
    if (date.getUTCMinutes() < 10) time += '0';
    time += date.getUTCMinutes() + ':';
    if (date.getUTCSeconds() < 10) time += '0';
    time += date.getUTCSeconds();
    //time += ':' + date.getUTCMilliseconds();
    return time;
}

function displayError(message) {
    var div = document.getElementById('errorDisplay');
    div.innerHTML = message + div.innerHTML;
}

function displayCurrentPosition(position) {
    // place the positional data into appropriate html blocks for demo
    // start with lat
    var placeholder = document.getElementById('latDisplay');
    placeholder.innerHTML = "LAT: " + position.coords.latitude;
    // now lon
    var placeholder = document.getElementById('lonDisplay');
    placeholder.innerHTML = "LON: " + position.coords.longitude;
    // now heading
    var placeholder = document.getElementById('headDisplay');
    placeholder.innerHTML = "HDG: " + position.coords.heading;
    // now heading
    var placeholder = document.getElementById('speedDisplay');
    placeholder.innerHTML = "SPD: " + position.coords.speed;
    // now time
    var placeholder = document.getElementById('timeDisplay');
    placeholder.innerHTML = "Updated: " + getTime()
}

function getCurrentPosition() {
    var id = getCurrentPositionRequest++;
    console.log('getCurrentPosition start - request ' + id);
    navigator.geolocation.getCurrentPosition(

	function(position) {
	    console.log('getCurrentPosition success - request ' + id);
	    console.log(position);
	    displayCurrentPosition(position);

	    // Update position variables
	    currentLat = position.coords.latitude;
	    currentLon = position.coords.longitude;

	    // Calculate distance and bearing to target
	    
	    // Display distance and bearing to target
	},

	function(error) {
	    console.log('getCurrentPosition error - request ' + id);
	    console.log(error);
	    displayError('<div>' + id + ' ' + getTime() + ' ' + error.message + '</div>');
	},

	{
	    timeout: 50000 + id,
	    maximumAge: Infinity,
	    enableHighAccuracy: true
	}

    );

}

function watchPosition() {
    var id = getCurrentPositionRequest++;
    console.log('watchPosition start - request ' + id);
    navigator.geolocation.watchPosition(

	function(position) {
	    //console.log('watchPosition success - request ' + id);
	    //console.log(position);
	    //displayCurrentPosition(position);

	    // Update position variables
	    currentLat = position.coords.latitude;
	    currentLon = position.coords.longitude;

	    // Calculate distance and bearing to target
	    var currentTargetDistance = find_distance(currentLat,currentLon,target.lat,target.lon);
	    var currentTargetBearing = find_bearing(currentLat,currentLon,target.lat,target.lon);
	    var heading = position.coords.heading;
	    var relativeBearing = currentTargetBearing - heading;
	    // this needs to be changed to a reletive bearing
	    //// maybe, ask what they would rather work with
	    //// I suspect the pointer should be relitive, but any read out should be true
	    // Display distance and bearing to target
	    var placeholder = document.getElementById('currentTargetDistance');
	    placeholder.innerHTML = "Distance to Target: " + currentTargetDistance;
	    
	    var placeholder = document.getElementById('currentTargetBearing');
	    placeholder.innerHTML = "True Bearing to Target: " + currentTargetBearing;

	    var placeholder = document.getElementById('currentRelativeBearing');
	    placeholder.innerHTML = "Relative Bearing to Target: " + relativeBearing;
	    
	},

	function(error) {
	    console.log('watchPosition error - request ' + id);
	    console.log(error);
	    displayError('<div>' + id + ' ' + getTime() + ' ' + error.message + '</div>');
	},

	{
	    timeout: 50000 + id,
	    maximumAge: Infinity,
	    enableHighAccuracy: true
	}

    );

}
function updateTarget() {
    // set target distance and bearing to equal the ones in the form
    var targetDistance = document.getElementsByName("targetDistance")[0].value;
    var targetBearing = document.getElementsByName("targetBearing")[0].value;

    // calculate target lat and lon
    // current lat and lon are stored as global variables
    target = find_endpoint(currentLat,currentLon,targetDistance,targetBearing);

    //display them
    // start with lat
    var placeholder = document.getElementById('targetLatDisplay');
    placeholder.innerHTML = "LAT: " + target.lat;
    // now lon
    var placeholder = document.getElementById('targetLonDisplay');
    placeholder.innerHTML = "LON: " + target.lon;

    

}




//setInterval(getCurrentPosition, 1000);
watchPosition();
</script>
    </head>
    <body>
    <h1>Guide Phone to Mark</h1>
    <h2>Current Position</h2>
    <p id="latDisplay">LAT: </p>
    <p id="lonDisplay">LON: </p>
    <p id="headDisplay">HDG: </p>
    <p id="speedDisplay">SPD: </p>
    <p id="timeDisplay">Updated: </p>


    <h2>Define Target</h2>
    <form>
    <p>Distance: <input type="text" name="targetDistance"> Meters</p>
    <p>Bearing: <input type="text" name="targetBearing"> Degrees True</p>
    <input type="button" value="Update Target" name="targetUpdater" onclick="updateTarget()">
    <p id="targetLatDisplay">Target LAT: </p>
    <p id="targetLonDisplay">Target LON: </p>
    </form>

    <h2>Guide to Target</h2>
    <p id="currentTargetDistance">Distance to Target: </p>
    <p id="currentTargetBearing">Bearing to Target: </p>
    <p id="currentRelativeBearing">Relative Bearing to Target: </p>

    <h2>Errors</h2>
    <div id="errorDisplay"></div>

    </body>
    </html>
